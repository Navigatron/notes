<!DOCTYPE html>
<html lang=" en-US">

	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		
	<!-- MathJax disabled on this page -->

		


		<!--[if lt IE 9]>
			<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
		<![endif]-->
		
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Arvo&family=Fira+Mono&family=Open+Sans&display=swap');
		</style>
		<link rel="stylesheet" href="/styles/index.css?v=1657689426821">

		<!-- Code Highlighting -->
		<link rel="stylesheet" href="https://raw.githubusercontent.com/PrismJS/prism-themes/master/themes/prism-one-light.css">
	</head>

	<body>
		<main>
			
			


<article>
	<p><a href="../">up</a></p>
<h1>housekeeping</h1>
<p>There is a test next class, wednesday. Exam 3. Room 3435, same as last times.</p>
<p>Block diagrams need:</p>
<ul>
<li>Labels</li>
<li>Inputs</li>
<li>Outputs</li>
</ul>
<p>Project1 oh no, try test is now up and running.</p>
<p>Experiment 7 will be released today, due Monday of thanksgiving week.</p>
<h1>nov12 - ALU continued</h1>
<p>Ai and Bi go into many different things, and the multiplexer decides what gets shipped out. So far, we have and, or, and addition.</p>
<h2>Subtraction</h2>
<p>A-B = A+(-B) = A+((!B)+1), due to Two's Complement</p>
<p>Why build a new circuit when we could just hijack the input to addition?</p>
<p>Use the magic of XOR:</p>
<p>A XOR 0 = A
A XOR 1 = !A</p>
<p>Therefore, B XOR (subtraction flag) makes B correct for the ADDer function - with the exception of the +1.</p>
<p>Oh no, getting very clever. Send the subtraction flag to the Carry-In of the low order bit. This handles the +1 when subtracting, and lets addition still have a zero.</p>
<h2>Truth Table so far</h2>
<p>Add/Sub | S1 | s0 | Function
---|---
0 | 0 | 0 | And
0 | 0 | 1 | Or
0 | 1 | 0 | Add
0 | 1 | 1 | ???
1 | 0 | 0 | And
1 | 0 | 1 | Or
1 | 1 | 0 | Subtract
1 | 1 | 1 | ???</p>
<p>There's some lost opportunity in that there's two ANDs and ORs, but this isn't a big problem. There's two slots we have left to define.</p>
<h2>Overflow</h2>
<p>If the carry in does not match the carry out of the high-order bit, there is overflow.</p>
<p>The XOR comes back! carry-in XOR carry-out returns 1 if overflow.</p>
<p>ALU has two outputs now - n-bit number, and overflow flag.</p>
<p>This only has meaning when using the full-adder - otherwise it's useless.</p>
<h2>Other things?</h2>
<p>Jumps don't need math, just appending. Shifting is done somewhere else.</p>
<p>Load word adds a register and a constant - we've already got addition.</p>
<p>How about slt? Set Less Than?</p>
<p><code>slt	rd, rs, rt</code></p>
<p>Subtract rt from rs into temp, and set rd to 1 if temp &lt; 0, aka if the sign bit is 1.</p>
<h2>Set if Less Than</h2>
<p>Send a zero to input 3 of all multiplexers except the low-order bit.</p>
<p>While input 3 is selected, the full-adder is still running. We can take the output of Full-adder 31 and send it to input 3 of the low order bit multiplexer.</p>
<p>That's complicated. Bit 31's full-adder also goes to the SLT line of bit 0. Everyone elses SLT line is zero - output of SLT is either 0000..0001 or 0000...0000</p>
<p>Now filling in the truth table.</p>
<h2>Truth Table so far, again</h2>
<p>Add/Sub | S1 | s0 | Function
---|---
0 | 0 | 0 | And
0 | 0 | 1 | Or
0 | 1 | 0 | Add
0 | 1 | 1 | <em>ERR - nothing useful.</em>
1 | 0 | 0 | And
1 | 0 | 1 | Or
1 | 1 | 0 | Subtract
1 | 1 | 1 | <strong>SLT</strong></p>
<h2>There's another one. BEQ - branch if equal.</h2>
<p>In this case, it does a full subtraction of the two args. They're equal if the result is all zeros. NOR together all the output wires, and we get a 1 if equal and a zero otherwise.</p>
<p>That output wire goes back to the control unit, so it can decide what to set $PC to next.</p>
<h2>That's the ALU. Here's the Block Diagram</h2>
<p>Should look like pants.</p>
<pre><code>       S:123
         |||
       |-+++-\
 A(32)-| ALU  \
       \       \
        \ IsZero|-1  (On if inputs are the same)
         |   Res|-32 (Result of operation)
    	 |OvrFlw|-1  (Flag if there was overflow)
        /       |
       /       /
 B(32)-|      /
       |-----/
</code></pre>
<h2>Register File</h2>
<pre><code>MIPS 32x32bit register file
   +--------------+
 5-|RA1           |
 5-|RA2         R1|-32
  -|Write         |
 5-|WA          R2|-32
32-|Wdata         |
   |              |
   +--------------+
</code></pre>
<p>RA1 decides what register to output R1
RA2 decides what register to output R2</p>
<p>Write is a flag - weather or not to write a register</p>
<p>WA decides what register to write to
Wdata is the data to write to register WA, if write is on.</p>
<p>Tune in next time for more register file</p>

</article>
			
			<footer>
				<hr>
				<p>
					&copy; <a href="https://ewitherington.me">Ethan Witherington</a> 2022
				</p>
			</footer>
		</main>
	</body>

</html>