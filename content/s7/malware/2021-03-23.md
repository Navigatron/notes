---
date: 2021-03-23
title: "C++ and object-oriented reversing"
---

[Index](../../../index.md) > [Malware](./index.md) > {{ page.date }}: {{ page.title }}

# {{ page.date }}: {{ page.title }}

> Oh NO.
> C++ and lack of sleep are my two fatal flaws.
> This is gonna be *rough*

- IDA Features
- Classes
- Structures
- VTables

**Base Class** - like a "superclass" in Java, other classes derive from this.

**Derived Class** - like a "subclass" in Java, this *derives* from a base class.

A **Vector** is better than an array, because it is dynamically growable.

## The Space Object Example

A *Space Object* is a *Base Class* with a *virtual function* called `Draw`.

> A virtual function is a function that *should* be overridden in the derived classes

We have a *Vector* of Space Object pointers, and we call the draw function on each one.

But! These objects are all *Derived Classes*, and they have their own draw functions that are specific to them.

- `Baseclass.function()` calls the base function directly
- `DerivedClass.function()` calls the derived function directly
- `BaseClassPointer->function()` calls the base function *virtually*
- `DerivedClassPointer->function()` calls the derived function *virtually*

**IMPORTANT**: The `BaseClassPointer` of `BaseClassPointer->function()` *might not be* a Base Class Pointer! That could be a derived class pointer, in a base class pointer box - and it can do that, since it derives from the base class. `Animal myAnimal = new Cow()` is perfectly valid! Then, since the function is called virtually:

```
BaseClassPointerButItsActuallyADerivedClassPointer -> function()
```

*Calls the dervived function, virtually!*

How the hell does this work?

## VTABLES

It's not the type of the pointer that decides what function is called - it's the actual object. Each object has a table of function pointers. Therefore, `ObjectPointer->toString()` checks that objects vtable for a reference to a toString.

Your Shape object probably has these fields:

- Character pointer, name
- Function pointer, draw

The Shape base class probably defined `printName`. The compiler knows to call this function for any and all instances of a Shape. Therefore, our objects don't need a pointer to it. Meanwhile, `draw` is a *pure virtual function*. The base class provides no definition for it. Each Shape object has a pointer to its own version of the draw function - squares and circles will be drawn differently.

Let's be more specific here - since each Rectangle object will have the same vTable, they all actually have a pointer to the same vTable.

```

My Shapes Array
+------------+
| PtrToShape |     My Rectangle                                           
+------------+     +-------------+                                        
| PtrToShape | --> | PtrToVTable | \
+------------+     +-------------+  \
| PtrToShape |     | PtrToName   |   \
+------------+     +-------------+    \    Rectangle vTable
| PtrToShape |                         >-> +--------------------+
+------------+                        /    | PtrToFunc: Draw    | --> void func Draw(Rectangle* self){}
| PtrToShape |     My Rectangle 2    /     +--------------------+
+------------+     +-------------+  /      | PtrToFunc: GetArea |
| PtrToShape | --> | PtrToVTable | /       +--------------------+
+------------+     +-------------+
                   | PtrToName   |
                   +-------------+
```

---

[Index](../../../index.md) > [Malware](./index.md) > {{ page.date }}: {{ page.title }}
