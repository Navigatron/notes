---
date: 2021-04-13
title: "SHELLCODE: Obfuscation; Process Environment Block; API Hashing"
---

[Index](../../../index.md) > [Malware](./index.md) > {{ page.date }}: {{ page.title }}

# {{ page.date }}: {{ page.title }}

Shellcode! What does it want?

Shellcode is the payload that is executed after a successful exploit. It tends to be very small, to fit in a buffer. It probably has multiple layers of obfuscation.

Position Independent Code (PIC) can't be sure where it will be loaded - so if it wants to use an api, it will have to find it.

Goals:

- Remain as stealthy as possible
    - Evade AV/IDS
    - Use obfuscation
- Locate and load libraries
- May commonly install other malware

Techniques:

- XOR obfuscation
- Walk the Process Environment Block (PEB)
- API Hashing
    - Conceals the APIs it wants to use

Commonly used APIs:

- CreateFile
- WinExec
- WriteFile
- LoadLibrary
- GetProcAddress

Look at this shellcode de-obfuscator:

```
0x000  jmp   0x400          ; Jump to the call
0x002  pop   eax            ; Pop the return address (start of encrypted content)
0x004  mov   ecx,    0xFF6  ; Put the length of the content in ecx
0x006  xor   [eax],  0xFE   ; Decrypt the content at eax
0x008  inc   eax            ; Increment eax - next line
0x00a  loop  0x6            ; Loop until ecx is decremented to zero
0x00c  jmp   0x402          ; Jump right into the decrypted payload
0x400  call  0x2            ; Pushes 0x402 to the stack (return address), head to 0x002
0x402  <Encrypted Content>  ;
```

## Process Environment Block

The PEB is located at a known location. It is a struct that contains lots of valuable information.

```c
typedef struct _PEB {
    BYTE                          Reserved1[2];
    BYTE                          BeingDebugged;
    BYTE                          Reserved2[1];
    PVOID                         Reserved3[2];
    PPEB_LDR_DATA                 Ldr;               // Look at this!
    PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
    PVOID                         Reserved4[3];
    PVOID                         AtlThunkSListPtr;
    PVOID                         Reserved5;
    ULONG                         Reserved6;
    PVOID                         Reserved7;
    ULONG                         Reserved8;
    ULONG                         AtlThunkSListPtr32;
    PVOID                         Reserved9[45];
    BYTE                          Reserved10[96];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE                          Reserved11[128];
    PVOID                         Reserved12[1];
    ULONG                         SessionId;
}
```

The _PEB_LDR_DATA looks like:

```c
typedef struct _PEB_LDR_DATA {
    BYTE       Reserved1[8];
    PVOID      Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
}
```

It has a LIST_ENTRY field. What's that?

```c
typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink; // Pointer to the next list entry
    struct _LIST_ENTRY *Blink;
}
```

How do we turn a list_entry into the actual content of the entry? WELL it turns out that the _list_entry struct is actually *wrapped* in another, larger struct. So if we just read past the end of it, we end up in the larger one. Here's the larger one:

```c
typedef struct _LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks; // Here's where _LIST_ENTRY is wrapped
    PVOID Reserved2[2];
    PVOID DllBase; // Here's a pointer to a loaded DLL
    PVOID EntryPoint;
    PVOID Reserved3;
    UNICODE_STRING FullDllName;
    BYTE Reserved4[8];
    PVOID Reserved5[3];
    union {
        ULONG CheckSum;
        PVOID Reserved6;
    };
    ULONG TimeDateStamp;
}
```

So:

- 0x30 is the _PEB
- _PEB + 0x0C = _PEB_LDR_DATA
- _PEB_LDR_DATA + 0x14 = _LIST_ENTRY
- _LIST_ENTRY + 0x00 = _LIST_ENTRY
- _LIST_ENTRY + 0x10 = DllBase

## API Hashing

Each library has an `export directory table`, which contains the relative addresses of:

- Functions Array
- Symbol Names Array
- Ordinals Array

The *Names* array contains names. The same index of a name in the *Ordinals* array holds the index of the corresponding function in the *functions* array.

To resolve a function, Shellcode must:

- Traverse the *Names* array
- Hash the name
- Check if the has matches the stored hash
- If so, read the *Ordinals* array at the same index
- Use that result as the index of the *functions* array to read
- Now we have the address of the desired function

## Visual Indicators

What does shellcode *look* like?

- Nop sleds
    - 0x909090909090...
- Certain opcodes
    - Call: 0xe8
    - Unconditional Jumps: 0xeb, 0xe9
    - Loops: ???

---

[Index](../../../index.md) > [Malware](./index.md) > {{ page.date }}: {{ page.title }}
